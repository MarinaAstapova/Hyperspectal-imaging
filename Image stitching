import cv2
import numpy as np
import os


def create_panorama(image_path):
    """
    map stitching
    :param image_path:
    :return:
    """
    paths = list(os.walk(image_path))
    folder = paths[0][2][0:]
    folder.sort()
    print('find {} images for stitching:{}'.format(len(folder), folder))
    base_image = cv2.resize(cv2.imread(image_path + '/' + folder[0], 1), (1000, 1000))

    for num, file in enumerate(folder):

        print('Complete {} %. {} of {}'.format(round(num / len(folder) * 100), num, len(folder) + 1))
        next_image = cv2.resize(cv2.imread(image_path + '/' + file, 1), (1000, 1000))
        orb = cv2.ORB_create()
        kp1, des1 = orb.detectAndCompute(next_image, None)
        kp2, des2 = orb.detectAndCompute(base_image, None)
        bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True, )
        matches = bf.match(des1, des2)
        matches = sorted(matches, key=lambda x: x.distance)
        matches = matches[:int(len(matches) * 0.3)]
        assert len(matches) > 8

        dst_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1, 1, 2)
        src_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1, 1, 2)
        M, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
        h1, w1 = next_image.shape[:2]
        h2, w2 = base_image.shape[:2]
        pts1 = np.float32([[0, 0], [0, h1], [w1, h1], [w1, 0]]).reshape(-1, 1, 2)
        pts2 = np.float32([[0, 0], [0, h2], [w2, h2], [w2, 0]]).reshape(-1, 1, 2)
        pts2 = cv2.perspectiveTransform(pts2, M)
        pts = np.concatenate((pts1, pts2), axis=0)
        [xmin, ymin] = np.int32(pts.min(axis=0).ravel() - 0.5)
        [xmax, ymax] = np.int32(pts.max(axis=0).ravel() + 0.5)
        t = [-xmin, -ymin]
        Ht = np.array([[1, 0, t[0]], [0, 1, t[1]], [0, 0, 1]])
        result = cv2.warpPerspective(base_image, Ht.dot(M), (xmax - xmin, ymax - ymin))
        result[t[1]:next_image.shape[0] + t[1], t[0]:next_image.shape[1] + t[0]] = next_image
        base_image = result

    print('map created {}'.format(result.shape))

    return result


panorama = create_panorama('./image')
cv2.imwrite('IMAGE.tif', panorama)
